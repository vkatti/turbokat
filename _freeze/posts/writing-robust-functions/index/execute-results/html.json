{
  "hash": "e0d21f37bfee62b586eab85a99a3dfdf",
  "result": {
    "markdown": "---\ntitle: \"Writing Robust R Functions\"\nsubtitle: \"Some designs to validate function arguments.\"\nabstract: \"This post demonstrates some techniques to make your R user-defined functions unbreakable (well, almost!) by checking if function arguments are missing, incorrect data type or just down-right invalid values and how to return meaningful error messages.\"\nauthor: Vishal Katti\ndate: 2022-01-18\nimage: https://i.imgur.com/hbjbLMN.gif\ncategories: [R, functions]\ncitation: true\nlicense: \"CC BY\"\nfilters:\n  - social-share\nshare:\n  permalink: \"https://vishalkatti.com/posts/writing-robust-functions\"\n  description: \"Check out this article on writing robust functions in R\"\n  twitter: true\n  facebook: true\n  reddit: true\n  stumble: false\n  tumblr: false\n  linkedin: true\n  email: true\n---\n\n\n\n\n## Introduction\n\nFunctions in R ( or any other programming language in general) allow us\nto encapsulate some lines of code that we want to run again and again.\nFunctions are the natural outcome of the **DRY**^[**D**on't **R**epeat\n**Y**ourself!] principle. Functions group together a couple of lines of\nconsistent logic making our code modular and consequently, easy to\nmanage. However, when we write functions, we need to ensure that they\nbehave exactly as we want them to and are able to handle whatever we\nthrow at them. By whatever, I mean any and all kinds of inputs. The idea\nof creating unbreakable code is idealistic. I say this since creating\nrobust functions requires additional code to handle the unwanted inputs\nand most useRs write functions during some one-time analysis. Hence we\nneed to be pragmatic about how much time and effort we spend trying to\nmake our functions robust. Maybe, we need our functions to be just\nrobust enough! All I am saying is, if you are creating functions that\nwill be used by you and only you i.e. if you have absolute control over\nwhat inputs would be provided to your functions, then you can forego\ncertain checks and the functions need not be unbreakable. But, if you\nintend to write functions that will be used by a larger audience, you\nneed to ensure that such functions are able to handle all kinds of\ninnocent and malicious intents.\n\n## What do we mean by Robust Functions?\n\nYou must be familiar with the *Garbage-In-Garbage-Out* philosophy of\nSoftware engineering. We can think of it in terms of functions, that,\ngiven garbage or bad input, you get garbage or bad output. For a\nfunction to be robust, it must behave in a consistent manner for known\nand correct inputs, however, more importantly, it mustn't give us\ngarbage for bad inputs. Rather, it must provide useful output (as\nmessages or instructions) which can be further used to inform the\nend-user about possible problems in the inputs to drive proper usage.\nThe useful output/s in case of bad inputs would ideally be a combination\nof clean early exit and easy-to-understand error messages. So we shall\ntry to implement *Garbage-In-Useful-Info-Out* by looking at some ways we\ncan build well-behaved and reliable functions.\n\nInput values passed to a function are more popularly known as arguments\nor parameters. A robust function must validate the function arguments\nbefore proceeding to implement the function logic. If this is not done,\nthen the bad arguments will cause some errors in the logic and display\nerror messages that the end-user may not be familiar with. Worst-case\nscenario is when the function doesn't encounter any errors and just\ngives bad results!! Surely, we do not want this unpredictable behavior.\n\n::: {style=\"text-align:center;\"}\n![Source: imgflip.com](https://i.imgflip.com/28bxz3.jpg){width=\"60%\"}\n:::\n\n## Our sweet, innocent and naive Function\n\nConsider the following function `make_date` that takes 3 numeric inputs\n`yyyy`, `mm` and `dd` and returns a single \\`Date\\` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date <-  function(yyyy, mm, dd) {\n  \n  # main logic : Concatenate the values and convert to Date\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\n}\n\nmy_date <- make_date(yyyy = 2022, mm = 1, dd = 31)\nmy_date\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-01-31\"\n```\n:::\n\n```{.r .cell-code}\nclass(my_date)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Date\"\n```\n:::\n:::\n\n\nWe will use `make_date` to demonstrate a couple of scenarios where this\nfunction can fail and the methods to safeguard against such scenarios.\n\n## Scenario 1: Missing Arguments\n\nThe most basic check we should perform before running the function logic\nis to confirm if all the required arguments are available. Think about\nhow your function should behave if one of the arguments, suppose `mm` is\nmissing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date(yyyy = 2022, dd = 31)\n```\n\n<pre style=\"color: red;\"><code>Error in paste(yyyy, mm, dd, sep = \"-\"): argument \"mm\" is missing, with no default\n</code></pre>\n:::\n\n\nNote that the error message shown to the user, is triggered, not from\nour function `make_date` but from the internal `paste` function. We do\nnot have any control over what error messages are shown when errors\noccur. In this case, we know specifically that this error is due to a\nmissing argument.\n\nThere are two ways to handle missing arguments:\n\n### 1.1 Early Exit\n\nIf a certain required argument is missing, we can stop the execution of\nthe function and show informative error message about which argument is\nmissing. Your friends here are the `missing` and `stop` functions. The\n`missing` function checks if the given argument is missing or is set to\nNULL and returns TRUE, else it returns FALSE. The `stop` function stops\nthe execution and displays the custom error message we provide. Using\nthese functions inside an `if` condition will let us check for missing\narguments. Let us modify our naive function to stop early when required\narguments are missing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date <-  function(yyyy, mm, dd) {\n  \n  # check missing arguments\n  if (missing(yyyy)) stop(\"argument `yyyy` is required.\")\n  if (missing(mm))   stop(\"argument `mm` is required.\")\n  if (missing(dd))   stop(\"argument `dd` is required.\")\n  \n  # main logic\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\n}\n\n# Calling the function without `mm` argument\nmake_date(yyyy = 2022, dd = 31)\n```\n\n<pre style=\"color: red;\"><code>Error in make_date(yyyy = 2022, dd = 31): argument `mm` is required.\n</code></pre>\n:::\n\n\nNote that here, we add three `if-missing-stop` statements, one for each\nrequired argument. We must do this if we want to display specific error\nmessages for each argument. There is another way to do the same but we\nwill look at it later. If we want to display a single error message, we\ncan do so by clubbing the `missing` functions inside an `any` which will\nreturn TRUE if any one of the arguments is missing. However, providing\nclear error messages becomes challenging in this method.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy_fun <- function(a, b, c) { \n  if(any(missing(a), missing(b), missing(c))) {\n    stop(\"One or more required arguments missing.\")\n  }\n  # Do something...\n}\ndummy_fun(a = 1)\n```\n\n<pre style=\"color: red;\"><code>Error in dummy_fun(a = 1): One or more required arguments missing.\n</code></pre>\n:::\n\n\n### 1.2 Sensible defaults with warnings\n\nIn some cases, we may need the function to use some sensible default\nvalue for the required arguments and continue execution. Here, we\ndisplay a warning message instead of an error message. This is required\nwhen the argument value is either considered to be obvious or the\nargument is not necessarily the most important one and is used only in\nextreme customization. **Providing default values to arguments makes\nthem optional arguments**. An example of default argument values can be\nseen in the `paste` function we have used earlier. The default value of\nthe separator argument `sep` is a single whitespace character.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(paste)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (..., sep = \" \", collapse = NULL, recycle0 = FALSE) \nNULL\n```\n:::\n:::\n\n\nSimilarly, we can provide some sensible defaults for the `make_date`\nfunction. Let's modify the function further to provide defaults for the\n`mm` and `dd` arguments only.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\n  \n  # check missing arguments\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\n  \n  # main logic\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\n}\n\n# Calling the function without `mm` and `dd` arguments\nmake_date(yyyy = 2022) # here, only `yyyy` is the required argument.\n```\n\n<pre style=\"color: orange;\"><code>Warning in make_date(yyyy = 2022): argument `mm` is missing. Using default value\nmm = 1 instead\n</code></pre><pre style=\"color: orange;\"><code>Warning in make_date(yyyy = 2022): argument `dd` is missing. Using default value\ndd = 1 instead\n</code></pre>::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-01-01\"\n```\n:::\n:::\n\n\nThere are a few concerns about using warnings instead of error messages.\nSome are listed here in this article from RBloggers [A Warning About\n`warning`](https://www.r-bloggers.com/2012/05/a-warning-about-warning/).\n\n## Scenario 2: Invalid Argument Data Type\n\nWe have defined `make_date` to accept 3 numeric arguments i.e. all 3\nmust be numbers. What would happen if someone tried to call `make_date`\nwith character, factor or boolean inputs?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date(yyyy = \"2022\", mm = \"5\", dd = \"20\") # works!! why?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-05-20\"\n```\n:::\n:::\n\n\nIn this case, the function works because when the arguments are combined\ninto a single string using `paste` , it matches the `format` argument of\nthe `as.Date` function in the main logic of `make_date` which is\n`as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date(yyyy = \"2022\", mm = \"May\", dd = \"1\") # works but shows NA !!!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nIn this case, all the arguments pass the checks but since we pass `2022-May-1` to `as.Date` which doesn't match the\n`format = '%Y-%m-%d'` thus giving `NA`.\n\nHow do we check if the values provided to the arguments are numbers or\nnumber-like? If the values are numbers, we let them pass. But if they\nare non-numeric, we must check if they can be converted to numbers i.e.\nwe must check if they are number-like. By number-like, I mean, will\ncoercing the value using `as.numeric` give us a numeric value or `NA` ?\nYou guessed it right, we will pass the values through `as.numeric` and\ncheck if the output is `NA` or not.\n\nWhat are the various data types in R that are not `numeric` but can look\nlike numbers? We have `character`, `factor` and `boolean` data types\nwhich can behave like numbers sometimes. Let's see a few scenarios.\n\n### Character arguments\n\n\n::: {.cell}\n\n```{.r .cell-code}\nYear <- c(\"2022\", \"TwentyTwo\")\nYear_num <- as.numeric(Year) # this should show a warning about NAs introduced by coercion\n```\n\n<pre style=\"color: orange;\"><code>Warning: NAs introduced by coercion\n</code></pre>\n\n```{.r .cell-code}\nYear_num # must show the number 2022 without quotes and one NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2022   NA\n```\n:::\n:::\n\n\nAs you can see in above example, when passed through `as.numeric`, the\nvalue \"2022\" gets converted to the number 2022 but the value \"TwentyTwo\"\ndoes not. Hence we can say \"2022\" is number-like but \"TwentyTwo\" is not.\n\n### Factor arguments\n\n\n::: {.cell}\n\n```{.r .cell-code}\nYear <- factor(c(\"2022\",\"2021\",\"TwentyTwo\"))\nas.numeric(Year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 1 3\n```\n:::\n\n```{.r .cell-code}\nYearX <- factor(c(\"2022\", \"X\"))\nas.numeric(YearX)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n\n```{.r .cell-code}\nYearY <- factor(2022)\nas.numeric(YearY)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nAs you can see from above examples, `factor` values do get converted to\nnumeric but do not give the right results. So we can safely say that\nfactors are not number-like.\n\nI will ignore `boolean` data types hoping that useRs are bright enough\nto not use Booleans while creating a Date!\n\nFrom the above examples, we can conclude that `numeric` values and\nnumber-like `character` values are the only valid data types that should\nbe allowed. Modifying our `make_date` function to include data type\nchecks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\n  \n  # check missing arguments\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\n  \n  # Check data types\n  if (!is.numeric(yyyy) & !is.character(yyyy)) {\n    stop(\"argument `yyyy` must be numeric\")\n  } else if (is.character(yyyy) & is.na(as.numeric(yyyy))) {\n    stop(\"argument `yyyy` must be numeric\")\n  }\n  if (!is.numeric(mm) & !is.character(mm)) {\n    stop(\"argument `mm` must be numeric\")\n  } else if (is.character(mm) & is.na(as.numeric(mm))) {\n    stop(\"argument `mm` must be numeric\")\n  }\n  if (!is.numeric(dd) & !is.character(dd)) {\n    stop(\"argument `dd` must be numeric\")\n  } else if (is.character(dd) & is.na(as.numeric(dd))) {\n    stop(\"argument `dd` must be numeric\")\n  }\n  \n  # main logic\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\n}\n\n# Calling the function with new datatype checks\nmake_date(yyyy = \"2022\", mm = \"May\", dd = \"1\")\n```\n\n<pre style=\"color: orange;\"><code>Warning in make_date(yyyy = \"2022\", mm = \"May\", dd = \"1\"): NAs introduced by\ncoercion\n</code></pre><pre style=\"color: red;\"><code>Error in make_date(yyyy = \"2022\", mm = \"May\", dd = \"1\"): argument `mm` must be numeric\n</code></pre>\n\n```{.r .cell-code}\nmake_date(yyyy = \"2022\", mm = factor(\"5\"), dd = \"1\")\n```\n\n<pre style=\"color: red;\"><code>Error in make_date(yyyy = \"2022\", mm = factor(\"5\"), dd = \"1\"): argument `mm` must be numeric\n</code></pre>\n:::\n\n\nNotice that the datatype check is lengthy and similar for all 3\narguments. We can apply **DRY** principle again and encapsulate that\ncode into a small function `is_numberlike` which will return `TRUE` or\n`FALSE` . Note that `is_numberlike` has no checks because it is an\ninternal function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function check if value is number or number-like.\nis_numberlike <- function(x){\n  if (!is.numeric(x) & !is.character(x)) {\n    # Early Exit 1 if value is neither numeric nor character\n    return(FALSE) \n  } else if (is.character(x) & is.na(as.numeric(x))) {\n    # Early Exit 2 if character value is not number-like.\n    return(FALSE) \n  }\n  return(TRUE)\n}\n```\n:::\n\n\nThus our `make_date` function with data types check will look as below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\n  \n  # check missing arguments\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\n  \n  # Check data types\n  if (!is_numberlike(yyyy)) stop(\"argument `yyyy` must be numeric\")\n  if (!is_numberlike(mm))   stop(\"argument `mm` must be numeric\")\n  if (!is_numberlike(dd))   stop(\"argument `dd` must be numeric\")\n  \n  # main logic\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\n}\n\n# Calling the function with new datatype checks\nmake_date(yyyy = \"TwentyTwo\", mm = \"5\", dd = 1)\n```\n\n<pre style=\"color: orange;\"><code>Warning in is_numberlike(yyyy): NAs introduced by coercion\n</code></pre><pre style=\"color: red;\"><code>Error in make_date(yyyy = \"TwentyTwo\", mm = \"5\", dd = 1): argument `yyyy` must be numeric\n</code></pre>\n\n```{.r .cell-code}\nmake_date(yyyy = \"2022\", mm = factor(\"5\"), dd = \"1\")\n```\n\n<pre style=\"color: red;\"><code>Error in make_date(yyyy = \"2022\", mm = factor(\"5\"), dd = \"1\"): argument `mm` must be numeric\n</code></pre>\n\n```{.r .cell-code}\nmake_date(yyyy = 2022, mm = 5, dd = \"one\")\n```\n\n<pre style=\"color: orange;\"><code>Warning in is_numberlike(dd): NAs introduced by coercion\n</code></pre><pre style=\"color: red;\"><code>Error in make_date(yyyy = 2022, mm = 5, dd = \"one\"): argument `dd` must be numeric\n</code></pre>\n:::\n\n\nOne of the most interesting features of R is vectorization! Due to this\nfeature, our function `make_date` behaves in interesting ways. In some\ncases, it is desirable and sometimes it is not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date(yyyy = 2022, mm = 1:12, dd = \"1\")\n```\n\n<pre style=\"color: orange;\"><code>Warning in if (is.character(x) & is.na(as.numeric(x))) {: the condition has\nlength > 1 and only the first element will be used\n</code></pre>::: {.cell-output .cell-output-stdout}\n```\n [1] \"2022-01-01\" \"2022-02-01\" \"2022-03-01\" \"2022-04-01\" \"2022-05-01\"\n [6] \"2022-06-01\" \"2022-07-01\" \"2022-08-01\" \"2022-09-01\" \"2022-10-01\"\n[11] \"2022-11-01\" \"2022-12-01\"\n```\n:::\n:::\n\n\nNote the above warnings. These warnings appear because the `if`\nstatement checks if the condition provided results in a single `TRUE` or\n`FALSE` value. However, the output of the check `is.na(as.numeric(mm))`\nis a boolean vector of length 12. But `if` needs only 1 `TRUE` or\n`FALSE`.\n\nThe output contains 12 date values since `paste` is vectorised, it\nrecycles the values for `yyyy` and `dd` to give us 12 dates!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmm <- 1:12\npaste(\"Month\", mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"Month 1\"  \"Month 2\"  \"Month 3\"  \"Month 4\"  \"Month 5\"  \"Month 6\" \n [7] \"Month 7\"  \"Month 8\"  \"Month 9\"  \"Month 10\" \"Month 11\" \"Month 12\"\n```\n:::\n:::\n\n\nWhat do we do if we want `make_date` to return just one date?\n\n## Scenario 3: Incorrect Argument Size\n\nTo ensure `make_date` gives you just one date, we must ensure that the\narguments have just value and is not a vector of multiple values i.e.\n`length(arg)==1`. Let's further add a few checks for the data size of\nthe arguments and rearrange the checks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\n  \n  # check missing arguments\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\n  \n  # Check argument lengths\n  if (length(yyyy)!=1) stop(paste0(\"Length of argument `yyyy` is \", length(yyyy),\". Must be only 1.\"))\n  if (length(mm)!=1)   stop(paste0(\"Length of argument `mm` is \", length(mm),\". Must be only 1.\"))\n  if (length(dd)!=1)   stop(paste0(\"Length of argument `dd` is \", length(dd),\". Must be only 1.\"))\n  \n  # Check data types\n  if (!is_numberlike(yyyy)) stop(\"argument `yyyy` must be numeric\")\n  if (!is_numberlike(mm))   stop(\"argument `mm` must be numeric\")\n  if (!is_numberlike(dd))   stop(\"argument `dd` must be numeric\")\n  \n  # main logic\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\n}\n\n# Calling function with new data size checks\nmake_date(yyyy = 2022, mm = 1:12, dd = \"01\")\n```\n\n<pre style=\"color: red;\"><code>Error in make_date(yyyy = 2022, mm = 1:12, dd = \"01\"): Length of argument `mm` is 12. Must be only 1.\n</code></pre>\n\n```{.r .cell-code}\nmake_date(yyyy = c(\"2021\",\"2022\"), mm = \"1\", dd = 1)\n```\n\n<pre style=\"color: red;\"><code>Error in make_date(yyyy = c(\"2021\", \"2022\"), mm = \"1\", dd = 1): Length of argument `yyyy` is 2. Must be only 1.\n</code></pre>\n\n```{.r .cell-code}\nmake_date(yyyy = 2022, mm = 1, dd = c(\"1\",\"2\"))\n```\n\n<pre style=\"color: red;\"><code>Error in make_date(yyyy = 2022, mm = 1, dd = c(\"1\", \"2\")): Length of argument `dd` is 2. Must be only 1.\n</code></pre>\n:::\n\n\n## A little detour...\n\nSo far we checked for missing arguments, arguments with bad data types\nand arguments with incorrect sizes. We've used the `stop` function along\nwith `if` to check for all failure conditions and show appropriate error\nmessages. When we use `stop`, we must specify all the failure conditions\nand the number of specific error messages goes up as number of arguments\nincreases.\n\nIn case of our `make_date`, if an argument is not missing, it must be a\nnumber-like value of length 1. To reduce the number of error messages,\nwe can combine the error messages for data type and length. for eg, the\nerror message could be *argument `yyyy` must be a number-like value of\nlength 1.*\n\nWouldn't it be easier if we just specify what is the success condition\naka the **\"happy path\"**, and show error for all other conditions? To do\nthis, we can use the `stopifnot` function that let's us specify all the\nhappy paths. See example below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy_sum <- function(a, b, c){\n  \n  # check missing\n  stopifnot(!missing(a) & !missing(b) & !missing(c))\n  \n  # check argument values\n  stopifnot(!is.na(a) & is.numeric(a) & length(a)==1,\n            !is.na(b) & is.numeric(b) & length(b)==1,\n            !is.na(c) & is.numeric(c) & length(c)==1\n            )\n  sum(a, b, c)\n}\n\ndummy_sum(b = 2, c = 3) # a is missing\n```\n\n<pre style=\"color: red;\"><code>Error in dummy_sum(b = 2, c = 3): !missing(a) & !missing(b) & !missing(c) is not TRUE\n</code></pre>\n\n```{.r .cell-code}\ndummy_sum(a = NA_integer_, b = 2, c = 3) # a has NA value\n```\n\n<pre style=\"color: red;\"><code>Error in dummy_sum(a = NA_integer_, b = 2, c = 3): !is.na(a) & is.numeric(a) & length(a) == 1 is not TRUE\n</code></pre>\n\n```{.r .cell-code}\ndummy_sum(a = 1, b = \"2\", c = 3) # b has non-numeric value\n```\n\n<pre style=\"color: red;\"><code>Error in dummy_sum(a = 1, b = \"2\", c = 3): !is.na(b) & is.numeric(b) & length(b) == 1 is not TRUE\n</code></pre>\n\n```{.r .cell-code}\ndummy_sum(a = 1, b = 2, c = 5:7)  # c has length != 1\n```\n\n<pre style=\"color: red;\"><code>Error in dummy_sum(a = 1, b = 2, c = 5:7): !is.na(c) & is.numeric(c) & length(c) == 1 are not all TRUE\n</code></pre>\n:::\n\n\nNote the error messages above. They are not so user-friendly. Luckily,\nwe can specify error messages in `stopifnot` by providing the error\nmessages as the names of the \"happy path\" conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy_sum <- function(a, b, c){\n  \n  # check missing\n  stopifnot(\"one or more required arguments missing\" = !missing(a) & !missing(b) & !missing(c))\n  \n  # check argument values\n  stopifnot(\"argument `a` must not be NA, must be a number of length 1\" = !is.na(a) & is.numeric(a) & length(a)==1,\n            \"argument `b` must not be NA, must be a number of length 1\" = !is.na(b) & is.numeric(b) & length(b)==1,\n            \"argument `c` must not be NA, must be a number of length 1\" = !is.na(c) & is.numeric(c) & length(c)==1\n            )\n  sum(a, b, c)\n}\n\ndummy_sum(b = 2, c = 3) # a is missing\n```\n\n<pre style=\"color: red;\"><code>Error in dummy_sum(b = 2, c = 3): one or more required arguments missing\n</code></pre>\n\n```{.r .cell-code}\ndummy_sum(a = NA_integer_, b = 2, c = 3) # a has NA value\n```\n\n<pre style=\"color: red;\"><code>Error in dummy_sum(a = NA_integer_, b = 2, c = 3): argument `a` must not be NA, must be a number of length 1\n</code></pre>\n\n```{.r .cell-code}\ndummy_sum(a = 1, b = \"2\", c = 3) # b has non-numeric value\n```\n\n<pre style=\"color: red;\"><code>Error in dummy_sum(a = 1, b = \"2\", c = 3): argument `b` must not be NA, must be a number of length 1\n</code></pre>\n\n```{.r .cell-code}\ndummy_sum(a = 1, b = 2, c = 5:7)  # c has length != 1\n```\n\n<pre style=\"color: red;\"><code>Error in dummy_sum(a = 1, b = 2, c = 5:7): argument `c` must not be NA, must be a number of length 1\n</code></pre>\n:::\n\n\nUsing `stopifnot` in our `make_date` function to combine the datatype\nand length checks, we get...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\n  \n  # check missing arguments\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\n  \n  \n  # Check argument types and length\n  stopifnot(\n    \"argument `yyyy` must be numeric with length 1\" = is_numberlike(yyyy) & length(yyyy)==1,\n    \"argument `mm` must be numeric with length 1\"   = is_numberlike(mm)   & length(mm)==1,\n    \"argument `dd` must be numeric with length 1\"   = is_numberlike(dd)   & length(dd)==1\n  )\n  \n  # main logic\n  as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\n}\n\nmake_date() # no arguments provided\n```\n\n<pre style=\"color: red;\"><code>Error in make_date(): argument `yyyy` is required.\n</code></pre>\n\n```{.r .cell-code}\nmake_date(yyyy = 2022, mm = 1:12, dd = 31) # Length mm not equal to 1\n```\n\n<pre style=\"color: orange;\"><code>Warning in if (is.character(x) & is.na(as.numeric(x))) {: the condition has\nlength > 1 and only the first element will be used\n</code></pre><pre style=\"color: red;\"><code>Error in make_date(yyyy = 2022, mm = 1:12, dd = 31): argument `mm` must be numeric with length 1\n</code></pre>\n\n```{.r .cell-code}\nmake_date(yyyy = 2022, mm = \"Jan\", dd = 31) # mm is not number-like\n```\n\n<pre style=\"color: orange;\"><code>Warning in is_numberlike(mm): NAs introduced by coercion\n</code></pre><pre style=\"color: red;\"><code>Error in make_date(yyyy = 2022, mm = \"Jan\", dd = 31): argument `mm` must be numeric with length 1\n</code></pre>\n\n```{.r .cell-code}\nmake_date(yyyy = 2022, dd = 31) # argument mm is missing but should work using default value\n```\n\n<pre style=\"color: orange;\"><code>Warning in make_date(yyyy = 2022, dd = 31): argument `mm` is missing. Using\ndefault value mm = 1 instead\n</code></pre>::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-01-31\"\n```\n:::\n:::\n\n\n## Scenario 4: Values of Arguments that result in invalid outputs\n\nFinally, what do we do when the arguments provided will definitely give\nus bad results despite passing all checks? In our case, `make_date`\ncreates a date but if we give it values that will result in an invalid\ndate, it will give us invalid results (remember\n*Garbage-In-Garbage-Out*?).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date(yyyy = 2022, mm = 13, dd = 1) # is there a 13th month?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nWe get `NA` because `as.Date` returns NA for invalid inputs with no\nerror messages or warnings! We can check the output and provide a\ngeneric error message.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_date <-  function(yyyy, mm = 1, dd = 1) {\n  # check missing arguments\n  if (missing(yyyy))  stop(\"argument `yyyy` is required.\") \n  if (missing(mm)) warning(\"argument `mm` is missing. Using default value mm = 1 instead\") \n  if (missing(dd)) warning(\"argument `dd` is missing. Using default value dd = 1 instead\")\n  \n  \n  # Check argument types and length\n  stopifnot(\n    \"argument `yyyy` must be numeric with length 1\" = is_numberlike(yyyy) & length(yyyy)==1,\n    \"argument `mm` must be numeric with length 1\"   = is_numberlike(mm)   & length(mm)==1,\n    \"argument `dd` must be numeric with length 1\"   = is_numberlike(dd)   & length(dd)==1\n  )\n  \n  # main logic\n  out <- as.Date(paste(yyyy, mm, dd, sep = \"-\"), format = \"%Y-%m-%d\")\n  if (is.na(out)) {\n    stop(\"Invalid values provided. Please check your inputs.\")\n  }\n  return(out)\n}\n\nmake_date(yyyy = 2022, mm = 13, dd = 1) # is there a 13th month?\n```\n\n<pre style=\"color: red;\"><code>Error in make_date(yyyy = 2022, mm = 13, dd = 1): Invalid values provided. Please check your inputs.\n</code></pre>\n\n```{.r .cell-code}\nmake_date(yyyy = 2022, mm = 2, dd = 31) # are there 31 days in February?\n```\n\n<pre style=\"color: red;\"><code>Error in make_date(yyyy = 2022, mm = 2, dd = 31): Invalid values provided. Please check your inputs.\n</code></pre>\n:::\n\n\nDo you think our function `make_date` is robust enough?\n\n::: {style=\"text-align:center;\"}\n![As robust as Superman! Source:\nImgur](https://i.imgur.com/hbjbLMN.gif)\n:::\n\n## Conclusion\n\nMaking functions robust requires some prior thought about its intended\nuse and audience. Based on this, we can decide what checks to implement,\nwhat to skip, whether to stop execution using error messages or to use\ndefault values with warnings. Checking for \"happy paths\" is simpler\ncompared to checking each and every bad input and providing specific\nerror messages. Too many different error messages for the same argument\ncould become a source of frustration of the end user, so consider\ncombining some checks and their error messages to be informative and\nprecise. Robustness, like everything else, in moderation, is good and\ngetting it \"just right\" takes time and dedicated effort. Happy Coding!\n\n## Citations & References\n\n-   [Techniques for writing robust R programs -\n    LexJansen](https://www.lexjansen.com/phuse/2014/ts/TS03.pdf)\n-   [R Programming for Data\n    Science](https://bookdown.org/rdpeng/rprogdatascience/functions.html)\n-   [A Warning About\n    warning](https://www.r-bloggers.com/2012/05/a-warning-about-warning/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}