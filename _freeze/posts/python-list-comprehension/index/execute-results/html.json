{
  "hash": "c6cd191a2db83a6f8f29d8f733957e93",
  "result": {
    "markdown": "---\ntitle: \"Python - List Comprehension\"\nsubtitle: \"Crafting Concise Lists with Python's List Comprehensions\"\nabstract: \"This post demonstrates Python's List Comprehension compared with the `for` loop and its usage.\" \nauthor: Vishal Katti\ndate: 2024-01-06\nimage: https://i.imgur.com/JIedILu.gif\ncategories: [Python, List]\ncitation: true\nlicense: \"CC BY\"\nfilters:\n  - social-share\nshare:\n  permalink: \"https://vishalkatti.com/posts/python-list-comprehension\"\n  description: \"Check out this article on List Comprehension in Python\"\n  twitter: true\n  facebook: true\n  reddit: true\n  stumble: false\n  tumblr: false\n  linkedin: true\n  email: true\n---\n\n# Intro\n\nIn the world of Python, lists are the most versatile containers for managing data. While `for` loops offer a traditional approach to creating and manipulating lists, Python offers a more elegant and efficient alternative: list comprehensions. Let's dive into this concise syntax and explore its advantages over traditional for loops.\n\n# Basic Syntax\n\nList comprehensions pack a powerful punch in a compact syntax. They allow you to create lists in a single line, combining iteration and expression evaluation within square brackets. Here's the most basic structure:\n\n``` python\nnew_list = [expression for item in iterable]\n```\n\nwhere\n\n-   `expression` is the value or logic applied to each item, which will create the items of the new list\n-   `item` is the variable that represents each element of the iterable\n-   `iterable` is the variable over which we iterate or 'loop'. This could be a list, tuple, dictionary, string or anything which can be considered an `iterable` in Python.\n\nThe equivalent `for` loop for the above operation is as follows:\n\n```python\nnew_list = []\nfor item in iterable:\n    new_list.append(expression)\n```\n\n\nLet's understand this with some working code. Suppose I have a list of numbers and I want a list that contains the same numbers multipled by 2 i.e. doubled.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nmy_nums = [1, 2, 3, 4, 5]\ndoubled_nums = [num*2 for num in my_nums]\n\n# Same operation using `for` loop\ndoubled_nums_for = []\nfor num in my_nums:\n  doubled_nums_for.append(num*2)\n\n\nprint(doubled_nums)\nprint(doubled_nums_for) # identical to `doubled_nums`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[2, 4, 6, 8, 10]\n[2, 4, 6, 8, 10]\n```\n:::\n:::\n\n\nIn the above Python code, `my_nums` is the iterable, the `num` variable in 2nd line represents each item in `my_nums` and `num*2` is the expression or logic that we apply to each `num`.\n\nlet's take one more example with a `dictionary`.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nmy_dict = {'Actor':'Tom', 'Director':'Tony', 'Writer':'Jim'}  \n# Bonus for guessing the movie!\n\n# new_list = [expression for item in iterable]\nroles = [role for role in my_dict.keys()]\npeople = [person for person in my_dict.values()]\n\nprint(roles)\nprint(people)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Actor', 'Director', 'Writer']\n['Tom', 'Tony', 'Jim']\n```\n:::\n:::\n\n\nAs you can see, the `item` variable can be named anything as this variable is active only within the scope of the list comprehension.\n\n# Advanced Syntax: Filtering\n\nWe use the following syntax when we want to create a new list with items that satisfy some condition.\n\n``` python\nfiltered_list = [expression for item in iterable if condition]\n```\n\nwhere\n\n-   `condition` is any logical expression that return `True` or `False`\n\nLet's see an example. Suppose I have a list of sentences and I want to filtered list which has the word 'whisper' in them.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nsentence_list = [\n   \"Sunrise paints the clouds in fiery hues, a silent alarm\",\n   \"Raindrops pitter-patter on cobblestones, a playful melo\",\n   \"Ocean waves whisper secrets to the sandy shore, tales o\",\n   \"Owl's amber eyes pierce the moonlit forest, a silent gu\",\n   \"Butterfly wings, stained glass windows fluttering throu\",\n   \"Laughter spills from a cozy cafe window, a warm invitat\",\n   \"Cracked pavement whispers forgotten stories, echoes of \",\n   \"Starry sky, a canvas splashed with diamonds, whispers o\",\n   \"Spice-laden wind dances through the market, teasing the\",\n   \"Tiny snail embarks on a grand journey, a blade of grass\"\n]\n\n\nfiltered_list = [sen for sen in sentence_list if 'whisper' in sen]\n\n# Same operation using `for` loop\nfiltered_list_for = []\nfor sen in sentence_list:\n  if 'whisper' in sen:\n    filtered_list_for.append(sen)\n\n\nprint(filtered_list)\nprint(filtered_list_for) # identical to `filtered_list`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Ocean waves whisper secrets to the sandy shore, tales o', 'Cracked pavement whispers forgotten stories, echoes of ', 'Starry sky, a canvas splashed with diamonds, whispers o']\n['Ocean waves whisper secrets to the sandy shore, tales o', 'Cracked pavement whispers forgotten stories, echoes of ', 'Starry sky, a canvas splashed with diamonds, whispers o']\n```\n:::\n:::\n\n\nIn the above code, the `condition` is `'whisper' in sen` which returns True or False for every `sen` sentence.\n\nLet's look at a more useful example. Here we create a JSON-formatted string using List Comprehension\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nimport pandas as pd\nimport json\n\n# Sample DataFrame\ndata = {'name': ['Alice', 'Bob', 'Charlie'], \n        'age': [25, 30, 20], \n        'city': ['New York', 'London', 'Paris']\n        }\ndf = pd.DataFrame(data)\n\n# Convert DataFrame to JSON using list comprehension\njson_list = [row.to_json() for index, row in df.iterrows()]\n\n# Convert list to JSON and print\nfor json_string in json_list:\n  print(json.dumps(json.loads(json_string), indent=4))\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    \"name\": \"Alice\",\n    \"age\": 25,\n    \"city\": \"New York\"\n}\n{\n    \"name\": \"Bob\",\n    \"age\": 30,\n    \"city\": \"London\"\n}\n{\n    \"name\": \"Charlie\",\n    \"age\": 20,\n    \"city\": \"Paris\"\n}\n```\n:::\n:::\n\n\nHere's what is happening in the code above.\n\n1.  Import Libraries:\\\n    `import pandas as pd`: Imports the pandas library for working with DataFrames.\\\n    `import json`: Imports the json library for working with JSON data.\n\n2.  Create DataFrame:\\\n    `data = {...}`: Creates a dictionary containing data for three columns: 'name', 'age', and 'city'.\\\n    `df = pd.DataFrame(data)`: Creates a DataFrame `df` from the dictionary `data.`\n\n3.  Convert DataFrame to JSON List:\\\n    `json_list = [row.to_json() for index, row in df.iterrows()]`: This line uses list comprehension to convert each row of the DataFrame into a JSON string and stores them in a list called `json_list.`\\\n    `iterrows()` iterates over the DataFrame, yielding index and row pairs.\\\n    `row.to_json()` converts each row into a JSON string.\n\n4.  Print Pretty-Printed JSON:\\\n    `for json_string in json_list:`: This loop iterates over each JSON string in the `json_list.`\\\n    `print(json.dumps(json.loads(json_string), indent=4))`: This line prints the JSON string with proper indentation:\\\n    `json.loads(json_string)` parses the JSON string into a Python dictionary.\\\n    `json.dumps()` re-serializes the dictionary back into a JSON string, applying indentation for readability.\n\n# Advanced Syntax: If-Else\n\nThe If-Else syntax allows us to take one action if the item satisfies a condition and another action if it does not. The syntax is as follows:\n\n``` python\nnew_list = [true_expr if condition else false_expr for item in iterable] \n```\n\nwhere\n\n-   `true_expr` is the expression which is evaluated when the `item` satisfies the `condition`\n-   `false_expr` is the expression which is evaluated when the `item` does not satisfy the `condition`\n\nLet's look at an example of this If-Else syntax. Suppose I have list of numbers with missing values. I want replace the missing values with the average value of the numbers.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport statistics\n\nnum_list = [10, 20, None, 40, None, 20, 10]\n\n# Filtering Syntax: Calculate mean with only the numbers which are not None\nmean = statistics.mean(num for num in num_list if num is not None)\nprint(f\"{mean=}\")\n\n# If-Else Syntax\nclean_list = [num if num is not None else mean for num in num_list]\n\n# This can also be written as\nclean_list2 = [mean if num is None else num for num in num_list]\n\n\n# Same operation using `for` loop\nclean_list_for = []\nfor num in num_list:\n  if num is None:\n    clean_list_for.append(mean)\n  else:\n    clean_list_for.append(num)\n\nprint(clean_list)\nprint(clean_list2)\nprint(clean_list_for) # Identical to `clean_list` and `clean_list2`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmean=20\n[10, 20, 20, 40, 20, 20, 10]\n[10, 20, 20, 40, 20, 20, 10]\n[10, 20, 20, 40, 20, 20, 10]\n```\n:::\n:::\n\n\n# Real-world Usage\n\nI have personally encountered various scenarios in my data journey where I have come across List of Lists! List comprehension is a great way to quickly flatten list of lists in one line of code.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# Create a list of lists containing strings\nwords = [[\"hello\", \"world\"], [\"how\", \"are\", \"you\"], [\"today\"]]\n\n# Nested Syntax\nflattened_words = [word for sublist in words for word in sublist]\n\n# Same Operation using `for` loop\nflattened_words_for = []\nfor sublist in words:\n  for word in sublist:\n    flattened_words_for.append(word)\n\nprint(flattened_words)\nprint(flattened_words_for) # Identical to `flattened_words`\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['hello', 'world', 'how', 'are', 'you', 'today']\n['hello', 'world', 'how', 'are', 'you', 'today']\n```\n:::\n:::\n\n\n# So what's best?\n\nList comprehensions are ideal when:\n\n-   Creating a new list based on an existing iterable.\n-   Applying simple transformations or filtering to elements.\n-   Prioritizing concise and readable code.\n\nFor loops are preferable when:\n\n-   Performing complex operations within the loop.\n-   Needing more control over the iteration process.\n-   Requiring side effects beyond list creation (e.g., printing, modifying variables).\n\n# Conclusion\n\nWhile list comprehensions offer a concise approach to list creation, for loops remain essential for broader iteration tasks in Python. For new developers, for loops are easier to understand and make far more sense than list comprehensions. They provide greater flexibility and control, allowing for complex operations, multiple statements within each iteration, and handling side effects (like printing, logging) that go beyond mere list creation. However, when the goal is straightforward list generation with simple transformations or filtering, list comprehensions often deliver a more elegant and efficient solution.\n\n# References\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}