{
  "hash": "7772f6940131c1614b8a96dec120f883",
  "result": {
    "markdown": "---\ntitle: \"Pivoting your tables with Tidyr: Part I\"\nsubtitle: \"Converting \\\"wide\\\" to \\\"long\\\" format\"\nabstract: \"This post demonstrates how to use `pivot_longer()` to convert your wide data to long data. This is part 1 of the Pivoting your tables with Tidyr series.\"\nauthor: Vishal Katti\ndate: 2022-07-08\nimage: https://i.imgur.com/0qMbFC1.gif\ncategories: [R, functions, tidyr, pivot]\ncitation: true\nlicense: \"CC BY\"\nfilters:\n  - social-share\nshare:\n  permalink: \"https://vishalkatti.com/posts/tidyr-pivot-longer\"\n  description: \"Check out this article on reshaping data.frames using {tidyr} in R\"\n  twitter: true\n  facebook: true\n  reddit: true\n  stumble: false\n  tumblr: false\n  linkedin: true\n  email: true\n---\n\n\n\n\n# Intro\n\nOne of the primary data manipulation operations is pivoting your tabular data from \"wide\" format to \"long\" format and vice-versa.\n\nThe idea is to make your tabular data \"tidy\" i.e.\n\n-   Every column is a variable.\n-   Every row is an observation.\n-   Every cell is a single value.\n\nIn other words, every column contains just one type of information, every row in the table is a snapshot or a version of the information your table captures and every cell contains just one piece of information.[^1]\n\nWhile the wide format is more human-readable, the long format is preferred and is desirable for data and plotting operations using R, Python or other data processing programming languages. The {tidyr} R package has functions that allow you to transform your tabular data between the two formats.\n\nIn this post, we will see how to convert a wide dataframe to long format using the *pivot_longer()* function from {tidyr} package.\n\n# The wide one\n\nConsider the following data table. It has been created from the famous Gapminder dataset. This table shows the average life expectancy in each continent for 2 years. While some of you may say that Gapminder data contains records for a lot more number of years, here we consider just the latest 2 years for ease of explanation and visual purposes.\n\n::: {style=\"text-align:center;\"}\n![Continent-wise Average Life Expectancy over last 2 years](https://i.imgur.com/sMJDveZ.png){#fig-wide}\n:::\n\n::: {style=\"text-align:center;\"}\n![The wide one](https://i.imgur.com/kbMDurH.png){#fig-wide2}\n:::\n\n`my_data` is in the wide format as we have continent names in column headers and average life expectancy values in each of those columns. To convert this tibble to the long format, we need to pull together the continent names in one column and their corresponding values into another column. See @fig-wide2\n\n\n# The long one\n\nThe long format of this table would ideally have only `year`, `continent` and `average_life_expectancy` columns and look something like the table below.\n\n::: {style=\"text-align:center;\"}\n![The long one](https://i.imgur.com/63PMzJ3.png){#fig-long width=\"60%\"}\n:::\n\nThe long format has repeated values of the column that are not gathered/collected. In this case, the `year` column gets its values repeated for each row.\n\nLet's recreate the above transformation in R. First, we create the `my_data` table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data <- data.frame(\n  year     = c(2002L, 2007L), \n  Africa   = c(53.33, 54.81), \n  Americas = c(72.42, 73.61), \n  Asia     = c(69.23, 70.73), \n  Europe   = c(76.70, 77.65), \n  Oceania  = c(79.74, 80.72)\n)\n\nknitr::kable(my_data)\n```\n\n::: {.cell-output-display}\n| year| Africa| Americas|  Asia| Europe| Oceania|\n|----:|------:|--------:|-----:|------:|-------:|\n| 2002|  53.33|    72.42| 69.23|  76.70|   79.74|\n| 2007|  54.81|    73.61| 70.73|  77.65|   80.72|\n:::\n:::\n\n\nTo convert this table into long format, we use the *pivot_longer()* function from {tidyr} R package. Let us see how to use this function.\n\n::: callout-tip\nUse \\`formals\\` to view all the formal arguments of a function and their default values. \\`formals\\` returns a named list.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr, quietly = TRUE, warn.conflicts = FALSE)\n\nformals(pivot_longer)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$data\n\n\n$cols\n\n\n$names_to\n[1] \"name\"\n\n$names_prefix\nNULL\n\n$names_sep\nNULL\n\n$names_pattern\nNULL\n\n$names_ptypes\nNULL\n\n$names_transform\nNULL\n\n$names_repair\n[1] \"check_unique\"\n\n$values_to\n[1] \"value\"\n\n$values_drop_na\n[1] FALSE\n\n$values_ptypes\nNULL\n\n$values_transform\nNULL\n\n$...\n```\n:::\n:::\n\n\nThe result of `formals(pivot_longer)` tells us that the minimum information needed to use this function is to provide values to the `data` and `cols` arguments as all other arguments have default values and hence, are optional.\n\nUsing only the minimum arguments with `pivot_longer()`, we get a long formatted tibble with the columns `year`, `name` and `value`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong_minimal <- pivot_longer(\n                        data      = my_data,\n                        cols      = c(\"Africa\", \"Americas\", \"Asia\", \"Europe\", \"Oceania\")\n                        )\n\nknitr::kable(long_minimal)\n```\n\n::: {.cell-output-display}\n| year|name     | value|\n|----:|:--------|-----:|\n| 2002|Africa   | 53.33|\n| 2002|Americas | 72.42|\n| 2002|Asia     | 69.23|\n| 2002|Europe   | 76.70|\n| 2002|Oceania  | 79.74|\n| 2007|Africa   | 54.81|\n| 2007|Americas | 73.61|\n| 2007|Asia     | 70.73|\n| 2007|Europe   | 77.65|\n| 2007|Oceania  | 80.72|\n:::\n:::\n\n\nNotice that the continent names and their corresponding average life expectancy values appear in columns named `name` and `value`. These are the default column names. We can change these column names by providing our own names to the arguments `names_to` and `values_to`.\n\nSince the `year` column is the only one that remains as is, we can rewrite the above `pivot_longer` statement as below\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_longer <- pivot_longer(data      = my_data,\n                               cols      = !year,\n                               names_to  = \"continent\",\n                               values_to = \"average_life_expectancy\")\n\nknitr::kable(my_data_longer)\n```\n\n::: {.cell-output-display}\n| year|continent | average_life_expectancy|\n|----:|:---------|-----------------------:|\n| 2002|Africa    |                   53.33|\n| 2002|Americas  |                   72.42|\n| 2002|Asia      |                   69.23|\n| 2002|Europe    |                   76.70|\n| 2002|Oceania   |                   79.74|\n| 2007|Africa    |                   54.81|\n| 2007|Americas  |                   73.61|\n| 2007|Asia      |                   70.73|\n| 2007|Europe    |                   77.65|\n| 2007|Oceania   |                   80.72|\n:::\n:::\n\n\nIf you are a visual person like me and wish to see this transformation with explanations, check out this GIF I made using good ol' Powerpoint.\n\n::: {style=\"text-align:center;\"}\n![{tidyr} pivot_longer() explained](https://i.imgur.com/0qMbFC1.gif){#fig-gif}\n:::\n\n# Conclusion\n\n`pivot_longer()` is the successor for the great `gather()` function and has many advantages over the latter. `pivot_longer()` repeats all the values in the columns that are not included in the `cols` argument. Therefore, if your dataframe/tibble had a primary key prior to the transformation, the primary key of your transformed \"longer\" dataframe is your old primary key + the new column created by `names_to`. This function has many other arguments that allow some truly great transformations. Mastering this function (and its wide counterpart) is a great skill upgrade while massaging your data to make it \"tidy\".\n\nHappy Gathering!\n\n# References\n\n-   Hadley Wickham and Maximilian Girlich (2022). tidyr: Tidy Messy Data. R package version 1.2.0. <https://CRAN.R-project.org/package=tidyr>\n-   Yihui Xie (2022). knitr: A General-Purpose Package for Dynamic Report Generation in R. R package version 1.39.\n\n[^1]: **Long vs. Wide Data: Whatâ€™s the Difference?**\n    https://www.statology.org/long-vs-wide-data/",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}