{
  "hash": "96dfc9cf5bed1f12161c8bedc4e073fb",
  "result": {
    "markdown": "---\ntitle: \"Programming with R {dplyr} - As I Understand It!!\"\nsubtitle: \"How to create your own functions using {dplyr}\"\nauthor: Vishal Katti\ndate: 07-17-2021\ncategories: [Rstats, dplyr, functions]\nimage: https://i.imgur.com/H9jo8OB.gif\nformat:\n  html:\n    code-line-numbers: true\n    toc: true\n    highlight-style: arrow\n---\n\n\n\n\n# Introduction\n\nThe purpose of this document is to act as a quick guide for myself and others to understand how to use `dplyr` effectively to create dynamic functions. The general assumption is that the reader is familiar with the `{dplyr}` package and how to use it for data wrangling.\n\nIn this document, we will explore how to create functions using the popular `dplyr` verbs like `select`, `filter`, `mutate`, `arrange` and finally `group_by` with `summarise`.\n\n### Inspiration\n\nI regularly deal with event-related information with event date and few other columns like event type, root cause etc. Most reports usually involve calculating number of events that took place on a monthly, quarterly or annual basis, sometimes split by event type, root cause and other columns. After a few reports I realized that I am basically writing the same code over and over again to calculate these KPIs. Keeping the `DRY (Don't Repeat Yourself)` principle in mind, I managed to write a few functions to calculate these KPIs with a few dynamic variables. Following is an attempt to articulate what I learnt while creating those functions.\n\n### Data\n\nWe shall use the Texas Housing Sales data, available as a tibble in the popular `ggplot2` package as reference data. It contains monthly information about the housing market in Texas provided by the TAMU real estate center, <https://www.recenter.tamu.edu/>. It has 8602 observations and 9 variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntxhousing <- ggplot2::txhousing\ndplyr::glimpse(txhousing)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 8,602\nColumns: 9\n$ city      <chr> \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene\", \"Abil~\n$ year      <int> 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, ~\n$ month     <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, ~\n$ sales     <dbl> 72, 98, 130, 98, 141, 156, 152, 131, 104, 101, 100, 92, 75, ~\n$ volume    <dbl> 5380000, 6505000, 9285000, 9730000, 10590000, 13910000, 1263~\n$ median    <dbl> 71400, 58700, 58100, 68600, 67300, 66900, 73500, 75000, 6450~\n$ listings  <dbl> 701, 746, 784, 785, 794, 780, 742, 765, 771, 764, 721, 658, ~\n$ inventory <dbl> 6.3, 6.6, 6.8, 6.9, 6.8, 6.6, 6.2, 6.4, 6.5, 6.6, 6.2, 5.7, ~\n$ date      <dbl> 2000.000, 2000.083, 2000.167, 2000.250, 2000.333, 2000.417, ~\n```\n:::\n:::\n\n\nWe shall refer the above data in all the following sections.\n\n# `select()`\n\nWhen using `dplyr` functions, the two most popular ways to pass column names is either as bare names i.e. column names without enclosing them in quotes like ``sales`` or ``volume`` OR pass them as a character string like \"sales\" or 'volume'. You could also pass a character vector like `c(\"sales\", \"volume\")`. In this section we will explore the 3 ways to dynamically select the columns we want.\n\n### Passing raw column names\n\nIn this method, we pass the raw name of the column we want to select and use the `embrace` of curly-curly brackets to pass the raw name. For multiple columns, we can pass the raw names as a single vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect_raw <- function(df, var) {\n  dplyr::select(.data = df, {{var}}) %>%     # embrace of curly-curly {{}} brackets\n    head()                                   # to limit the number of output rows in this example.\n}\nselect_raw(txhousing, sales)                 # pass single raw name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 1\n  sales\n  <dbl>\n1    72\n2    98\n3   130\n4    98\n5   141\n6   156\n```\n:::\n\n```{.r .cell-code}\nselect_raw(txhousing, c(sales, volume))      # pass a vector of raw names for multiple columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 2\n  sales   volume\n  <dbl>    <dbl>\n1    72  5380000\n2    98  6505000\n3   130  9285000\n4    98  9730000\n5   141 10590000\n6   156 13910000\n```\n:::\n:::\n\n\nIf passing multiple raw names as vector as in the `select_raw()` feels like an unnecessary complication, try the next method.\n\n### Passing multiple raw column names using ... argument\n\nIn this method, we use the `.` argument to pass the raw names of the columns we want to select.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_select <- function(df, ...) {\n  dplyr::select(.data = df, ...) %>% \n    head()\n}\n\nmy_select(txhousing, sales, volume)          # pass multiple raw names directly\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 2\n  sales   volume\n  <dbl>    <dbl>\n1    72  5380000\n2    98  6505000\n3   130  9285000\n4    98  9730000\n5   141 10590000\n6   156 13910000\n```\n:::\n:::\n\n\n### Passing a character vector of column names\n\nIf we have the column names as a character vector, we use the `all_of` function to pass the character vector to the internal `select` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_select_char <- function(df, cols) {\n  dplyr::select(.data = df, dplyr::all_of(cols)) %>% \n    head()\n}\n\nmy_cols <- c(\"sales\",\"volume\")\nmy_select_char(txhousing, my_cols)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 2\n  sales   volume\n  <dbl>    <dbl>\n1    72  5380000\n2    98  6505000\n3   130  9285000\n4    98  9730000\n5   141 10590000\n6   156 13910000\n```\n:::\n:::\n\n\n# `filter()`\n\nIn the previous section, we passed column names either as bare names or character strings. `filter()` takes one or more expressions/conditions that result in a logical vector, with same length as number of rows in the data.frame/tibble and returns only those rows for which the expression/condition returns `TRUE`. Following are 2 ways to pass these logical expressions/conditions. I'm using expression and condition interchangeably here. In this context, a condition is an expression that results in a boolean `TRUE/FALSE` result.\n\n### Passing single raw criteria\n\nIn this method, we pass the condition `sales > 8000` as a raw/bare expression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter_raw <- function(df, cond) {\n  dplyr::filter(.data = df, {{cond}})        # embrace of curly-curly {{}} brackets\n}\n\nfilter_raw(txhousing, sales > 8000)          # Pass a single raw criterion\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 9\n   city     year month sales     volume median listings inventory  date\n   <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n 1 Houston  2006     5  8040 1602621368 151200    35398       5.5 2006.\n 2 Houston  2006     6  8628 1795898108 155200    36281       5.6 2006.\n 3 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\n 4 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\n 5 Houston  2013     8  8155 2083377894 186700    21366       3.3 2014.\n 6 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\n 7 Houston  2014     7  8391 2278932511 199700    20214       3   2014.\n 8 Houston  2014     8  8167 2195184825 202400    20007       2.9 2015.\n 9 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\n10 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\n```\n:::\n:::\n\n\nDo you think we can pass multiple bare conditions as a vector, like we did for `select_raw()` in the previous section? Let us try passing multiple raw criteria as a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter_raw(txhousing, c(sales > 8000, year > 2010))\n```\n\n<pre style=\"color: red;\"><code>Error in `dplyr::filter()`:\n! Problem while computing `..1 = c(sales > 8000, year > 2010)`.\nx Input `..1` must be of size 8602 or 1, not size 17204.\n</code></pre>\n:::\n\n\nPassing multiple raw criteria as a vector doesn't work like it works for `select_raw()` function. Let us understand why. Consider the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- c(TRUE, TRUE)                           # boolean vector of length = 2\nB <- c(FALSE, FALSE)                         # boolean vector of length = 2\nX <- c(A, B)\nX\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\nNotice that length of X is 4. Similarly, `sales > 8000` evaluates to a TRUE/FALSE boolean vector of length 8602 (equal to number of rows in `txhousing`) and so does `year > 2010`. So the vector `c(sales > 8000, year > 2010)` becomes a TRUE/FALSE boolean vector of length 17204, which results in an error.\n\n### Passing multiple raw criteria using ... argument\n\nTo pass multiple raw criteria, we can use the `...` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_filter <- function(df, ...) { \n  dplyr::filter(.data = df, ...)                # pass the dots argument\n  }\n\nmy_filter(txhousing, sales > 8000, year > 2010) # pass multiple raw criteria\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 x 9\n  city     year month sales     volume median listings inventory  date\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n1 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\n2 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\n3 Houston  2013     8  8155 2083377894 186700    21366       3.3 2014.\n4 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\n5 Houston  2014     7  8391 2278932511 199700    20214       3   2014.\n6 Houston  2014     8  8167 2195184825 202400    20007       2.9 2015.\n7 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\n8 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\n```\n:::\n:::\n\n\n### Passing single criteria as a character string\n\nBy default, `dplyr::filter()` does not accept conditions as character strings. Following is an example which results in error\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::filter(txhousing, \"sales > 8000\")\n```\n\n<pre style=\"color: red;\"><code>Error in `dplyr::filter()`:\n! Problem while computing `..1 = \"sales > 8000\"`.\nx Input `..1` must be a logical vector, not a character.\n</code></pre>\n:::\n\n\nWe need to convert the character condition into a raw expression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_filter_string <- function(df, cond) {\n  dplyr::filter(.data = df, eval(parse(text = cond)))   # convert text to raw criterion\n}\n\nmy_filter_string(txhousing, \"sales > 8000\")             # pass single text string as criteria\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 9\n   city     year month sales     volume median listings inventory  date\n   <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n 1 Houston  2006     5  8040 1602621368 151200    35398       5.5 2006.\n 2 Houston  2006     6  8628 1795898108 155200    36281       5.6 2006.\n 3 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\n 4 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\n 5 Houston  2013     8  8155 2083377894 186700    21366       3.3 2014.\n 6 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\n 7 Houston  2014     7  8391 2278932511 199700    20214       3   2014.\n 8 Houston  2014     8  8167 2195184825 202400    20007       2.9 2015.\n 9 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\n10 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\n```\n:::\n:::\n\n\nThe special sauce here is the `eval(parse(text = ...))` combo that converts the long text criteria into a single raw criteria and passes it to the internal `filter()` function.\n\n### Passing multiple criteria as character vector\n\nWhat if want to pass multiple criteria as a string vector? In such a situation, we must combine all the string conditions into a single long string condition using `paste0(..., collapse = \" & \")`. The `paste0(\"(\", cond, \")\", collapse = \" & \")` combines all the criteria into a single long criteria, but still a text string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_filter_strings <- function(df, cond) { \n  filter_text <- paste0(\"(\", cond, \")\", collapse = \" & \")   # combine all criteria\n  message(\"Filter Condition: \", filter_text)                # (OPTIONAL) show the combined filter string\n  dplyr::filter(.data = df, eval(parse(text = filter_text)))# convert text to raw criterion\n  }\n\nmy_filter_criteria <- c(\"sales > 8000\", \"year > 2010\")\nmy_filter_strings(txhousing, my_filter_criteria)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFilter Condition: (sales > 8000) & (year > 2010)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 x 9\n  city     year month sales     volume median listings inventory  date\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n1 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\n2 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\n3 Houston  2013     8  8155 2083377894 186700    21366       3.3 2014.\n4 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\n5 Houston  2014     7  8391 2278932511 199700    20214       3   2014.\n6 Houston  2014     8  8167 2195184825 202400    20007       2.9 2015.\n7 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\n8 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_filter_criteria_with_OR <- c(\"sales > 8000 | sales < 50\", \"year > 2010\")\n\n# NOTE: OR criteria must be a single string separated by pipe '|' as in example below.\nmy_filter_strings(txhousing, my_filter_criteria_with_OR)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFilter Condition: (sales > 8000 | sales < 50) & (year > 2010)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 315 x 9\n   city         year month sales  volume median listings inventory  date\n   <chr>       <int> <int> <dbl>   <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n 1 Brownsville  2011     1    48 4974408  83300      784      12.6 2011 \n 2 Brownsville  2011     2    47 5558575 101400      776      12.7 2011.\n 3 Brownsville  2011     7    47 4807019  91200      749      13.1 2012.\n 4 Brownsville  2011    12    39 4203440  86800      726      12.4 2012.\n 5 Brownsville  2012     1    43 3892348  85000      791      13.6 2012 \n 6 Brownsville  2012     3    27 2976148  93800      734      13.3 2012.\n 7 Brownsville  2012    11    41 5115393  99000      807      14   2013.\n 8 Brownsville  2013    11    38 4824930 108000      859      13.4 2014.\n 9 Brownsville  2015     1    41 5400796  97000      733      10.7 2015 \n10 Galveston    2011     1    43 8882961 170000     1015      13.7 2011 \n# ... with 305 more rows\n```\n:::\n:::\n\n\n# `mutate()`\n\n`mutate()` allows you to add new columns or modify existing columns. In the example below, we will create a new column `volume_in_millions` from the existing column `volume`. The names of both the columns can be passed to the function either as raw names or character strings.\n\n### Passing the column name as raw name\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate_raw <- function(df, new_col_raw, old_col_raw, num = 1) { \n  dplyr::mutate(.data = df, {{new_col_raw}} := {{old_col_raw}}/num) %>% \n    head()\n}\n\ntxhousing %>% \n  select(city, year, month, volume) %>% \n  mutate_raw(vol_in_millions, volume, 1E6) # pass raw column names w/o quotes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 5\n  city     year month   volume vol_in_millions\n  <chr>   <int> <int>    <dbl>           <dbl>\n1 Abilene  2000     1  5380000            5.38\n2 Abilene  2000     2  6505000            6.50\n3 Abilene  2000     3  9285000            9.28\n4 Abilene  2000     4  9730000            9.73\n5 Abilene  2000     5 10590000           10.6 \n6 Abilene  2000     6 13910000           13.9 \n```\n:::\n:::\n\n\n### Passing the new variable name as character string (direct)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate_text <- function(df, new_col_str, old_col_str, num = 1) { \n  dplyr::mutate(.data = df, {{new_col_str}} := df[[old_col_str]]/num) %>% \n    head()\n}\n\ntxhousing %>% \n  select(city, year, month, volume) %>%\n  mutate_text(\"vol_in_millions\", \"volume\", 1E6) # pass column names as strings\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 5\n  city     year month   volume vol_in_millions\n  <chr>   <int> <int>    <dbl>           <dbl>\n1 Abilene  2000     1  5380000            5.38\n2 Abilene  2000     2  6505000            6.50\n3 Abilene  2000     3  9285000            9.28\n4 Abilene  2000     4  9730000            9.73\n5 Abilene  2000     5 10590000           10.6 \n6 Abilene  2000     6 13910000           13.9 \n```\n:::\n:::\n\n\n### Passing the new variable name as character string (indirect)\n\nInstead of passing the name of the variable as a character string as an argument, we can pass a variable containing the name of the variable. In the below example, the name of the new variable is stored in `new_var`. Using the new `{glue}` syntax, enabled by the walrus operator `:=`, we substitute the `new_var` variable with its value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate_var <- function(df, new_col_var, old_col_var, num = 1) {\n  dplyr::mutate(.data = df, \"{new_col_var}\" := df[[old_col_var]]/num) %>% \n    head()\n}\n\nnew_var <- \"vol_in_millions\"\nold_var <- \"volume\"\n\ntxhousing %>% \n  select(city, year, month, volume) %>%\n  mutate_var(new_var, old_var, 1E6)  # pass column names as variables\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 5\n  city     year month   volume vol_in_millions\n  <chr>   <int> <int>    <dbl>           <dbl>\n1 Abilene  2000     1  5380000            5.38\n2 Abilene  2000     2  6505000            6.50\n3 Abilene  2000     3  9285000            9.28\n4 Abilene  2000     4  9730000            9.73\n5 Abilene  2000     5 10590000           10.6 \n6 Abilene  2000     6 13910000           13.9 \n```\n:::\n:::\n\n\n# `arrange()`\n\n`arrange()` sorts the rows of a data frame by the values of selected columns. By default, it sorts in Ascending order. To force a column to sort in Descending order, we must use the `desc()` function.\n\n### Passing single raw name\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange_raw <- function(df, var) {\n  dplyr::arrange(.data = df, {{var}}) %>%    # embrace of curly-curly {{}} brackets\n    head()\n}\n\narrange_raw(txhousing, sales)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 9\n  city                year month sales  volume median listings inventory  date\n  <chr>              <int> <int> <dbl>   <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n1 San Marcos          2011    10     6 1156999 180000      163       8.3 2012.\n2 Harlingen           2000     7     9 1110000  87500      719      30.8 2000.\n3 South Padre Island  2011     1     9 2088500 225000     1258      55.7 2011 \n4 San Marcos          2011     1    10 1482310 140000      165       7.5 2011 \n5 San Marcos          2011    12    10 1561250 140000      148       8   2012.\n6 San Marcos          2014    11    10 1506878 146700       96       4   2015.\n```\n:::\n\n```{.r .cell-code}\narrange_raw(txhousing, desc(sales))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 9\n  city     year month sales     volume median listings inventory  date\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n1 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\n2 Houston  2006     6  8628 1795898108 155200    36281       5.6 2006.\n3 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\n4 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\n5 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\n6 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\n```\n:::\n:::\n\n\n`arrange_raw()` fails when we pass multiple raw names as a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange_raw(txhousing, c(sales, volume))\n```\n\n<pre style=\"color: red;\"><code>Error in `dplyr::arrange()`:\n! Problem with the implicit `transmute()` step.\nx Problem while computing `..1 = c(sales, volume)`.\nx `..1` must be size 8602 or 1, not 17204.\n</code></pre>\n:::\n\n\n### Passing multiple raw names using `...` argument\n\nTo pass multiple raw names, we must use the `...` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange_raw_multiple <- function(df, ...) {\n  dplyr::arrange(.data = df, ...) %>% \n    head()\n}\n\narrange_raw_multiple(txhousing, city, sales)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 9\n  city     year month sales  volume median listings inventory  date\n  <chr>   <int> <int> <dbl>   <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n1 Abilene  2003     1    68 5385000  70000      668       5.4  2003\n2 Abilene  2011     1    68 8834493 123300      809       6.1  2011\n3 Abilene  2009     1    70 8414801  92900      861       6.3  2009\n4 Abilene  2000     1    72 5380000  71400      701       6.3  2000\n5 Abilene  2010     1    73 9130783 112200      868       6.4  2010\n6 Abilene  2001     1    75 5730000  64500      779       6.8  2001\n```\n:::\n\n```{.r .cell-code}\narrange_raw_multiple(txhousing, city, desc(sales))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 9\n  city     year month sales   volume median listings inventory  date\n  <chr>   <int> <int> <dbl>    <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n1 Abilene  2015     7   268 45845730 148700      986       5   2016.\n2 Abilene  2015     6   260 41396230 141500      965       5   2015.\n3 Abilene  2007     7   239 29315000 114300      940       5.2 2008.\n4 Abilene  2013     8   236 30777727 120000      976       5.4 2014.\n5 Abilene  2014     7   231 35861350 145800     1033       5.8 2014.\n6 Abilene  2005     6   230 24050000  92500      664       4.1 2005.\n```\n:::\n:::\n\n\n### Pass single column name as string\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange_str <- function(df, var, .desc = FALSE) {\n  if (.desc) {\n    dplyr::arrange(.data = df, desc(df[[var]])) %>% head()\n  } else {\n    dplyr::arrange(.data = df, df[[var]]) %>% head()\n  }\n}\n\narrange_str(txhousing, \"sales\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 9\n  city                year month sales  volume median listings inventory  date\n  <chr>              <int> <int> <dbl>   <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n1 San Marcos          2011    10     6 1156999 180000      163       8.3 2012.\n2 Harlingen           2000     7     9 1110000  87500      719      30.8 2000.\n3 South Padre Island  2011     1     9 2088500 225000     1258      55.7 2011 \n4 San Marcos          2011     1    10 1482310 140000      165       7.5 2011 \n5 San Marcos          2011    12    10 1561250 140000      148       8   2012.\n6 San Marcos          2014    11    10 1506878 146700       96       4   2015.\n```\n:::\n\n```{.r .cell-code}\narrange_str(txhousing, \"sales\", .desc = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 9\n  city     year month sales     volume median listings inventory  date\n  <chr>   <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n1 Houston  2015     7  8945 2568156780 217600    23875       3.4 2016.\n2 Houston  2006     6  8628 1795898108 155200    36281       5.6 2006.\n3 Houston  2013     7  8468 2168720825 187800    21497       3.3 2014.\n4 Houston  2015     6  8449 2490238594 222400    22311       3.2 2015.\n5 Houston  2013     5  8439 2121508529 186100    20526       3.3 2013.\n6 Houston  2014     6  8391 2342443127 211200    19725       2.9 2014.\n```\n:::\n:::\n\n\n### Pass multiple column name as string\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange_str_multiple <- function(df, var, desc = FALSE) {\n  if (desc) {\n    dplyr::arrange(.data = df, desc(df[var])) %>% head()\n  } else {\n    dplyr::arrange(.data = df, df[var]) %>% head()\n  }\n}\n\n# This function arranges the dataframe either all ascending\n# or all descending. Definitely need a better example.\n\narrange_str_multiple(txhousing, c(\"year\", \"month\", \"sales\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 9\n  city         year month sales  volume median listings inventory  date\n  <chr>       <int> <int> <dbl>   <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n1 Paris        2000     1    19 1440000  71700      286       7.5  2000\n2 San Marcos   2000     1    22 2380000 106700      190       6.3  2000\n3 Lufkin       2000     1    28 2280000  68000       NA      NA    2000\n4 Harlingen    2000     1    31 3910000  87500      644      24.9  2000\n5 Galveston    2000     1    37 4555000  95000      636       9.1  2000\n6 Port Arthur  2000     1    40 3090000  68300      314       5.6  2000\n```\n:::\n\n```{.r .cell-code}\narrange_str_multiple(txhousing, c(\"year\", \"month\", \"sales\"), desc = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 9\n  city           year month sales     volume median listings inventory  date\n  <chr>         <int> <int> <dbl>      <dbl>  <dbl>    <dbl>     <dbl> <dbl>\n1 Houston        2015     7  8945 2568156780 217600    23875       3.4 2016.\n2 Dallas         2015     7  7038 2021907410 233000    12292       2.4 2016.\n3 Austin         2015     7  3466 1150381553 264600     7913       3   2016.\n4 San Antonio    2015     7  2962  704891602 198100     9462       4.1 2016.\n5 Collin County  2015     7  1861  613669702 292600     2809       2.1 2016.\n6 Fort Bend      2015     7  1372  431875327 280400     3328       3.1 2016.\n```\n:::\n:::\n\n\n# `group_by()`\n\nIn `group_by()`, we *select* which columns to, well, group by! (Damn these well-named functions!). So one can use the same techniques as `select()` to choose the columns.\n\nIn the following examples, we will create only one summarised value `total_sales` for simplicity.\n\n### Passing single raw name\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_raw <- function(df, grp) {\n  df %>% \n    group_by({{grp}}) %>% \n    summarise(total_sales = sum(sales, na.rm = TRUE),\n              .groups = 'drop')  %>% \n    head(n=5)\n}\n\ngroup_raw(txhousing, year)        # Sum of sales per year\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n   year total_sales\n  <int>       <dbl>\n1  2000      222483\n2  2001      231453\n3  2002      234600\n4  2003      253909\n5  2004      283999\n```\n:::\n\n```{.r .cell-code}\ngroup_raw(txhousing, month)       # Sum of sales per month\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n  month total_sales\n  <int>       <dbl>\n1     1      245924\n2     2      296410\n3     3      386909\n4     4      397332\n5     5      448968\n```\n:::\n:::\n\n\n### Passing multiple raw names using the `...` operator\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_raw_multiple <- function(df, ...) {\n  df %>% \n    group_by(...) %>% \n    summarise(total_sales = sum(sales, na.rm = TRUE),\n              .groups = 'drop')  %>% \n    head(n = 5)\n}\n\ngroup_raw_multiple(txhousing, year)              # Sum of sales per year\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n   year total_sales\n  <int>       <dbl>\n1  2000      222483\n2  2001      231453\n3  2002      234600\n4  2003      253909\n5  2004      283999\n```\n:::\n\n```{.r .cell-code}\ngroup_raw_multiple(txhousing, year, month)       # Sum of sales per month\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 3\n   year month total_sales\n  <int> <int>       <dbl>\n1  2000     1       11411\n2  2000     2       15674\n3  2000     3       20202\n4  2000     4       18658\n5  2000     5       22388\n```\n:::\n:::\n\n\n### Passing single or multiple column names as character string\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_str <- function(df, grp) {\n  df %>% \n    group_by(df[grp]) %>% \n    summarise(total_sales = sum(sales, na.rm = TRUE),\n              .groups = 'drop')  %>% \n    head(n=5)\n}\n\ngroup_str(txhousing, \"year\")                   # Sum of sales per year\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n   year total_sales\n  <int>       <dbl>\n1  2000      222483\n2  2001      231453\n3  2002      234600\n4  2003      253909\n5  2004      283999\n```\n:::\n\n```{.r .cell-code}\ngroup_str(txhousing, c(\"year\", \"month\"))       # Sum of sales per month\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 3\n   year month total_sales\n  <int> <int>       <dbl>\n1  2000     1       11411\n2  2000     2       15674\n3  2000     3       20202\n4  2000     4       18658\n5  2000     5       22388\n```\n:::\n\n```{.r .cell-code}\n# The same column names can be passed as variables containing the character names\nyr <- \"year\"\ngroup_str(txhousing, yr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n   year total_sales\n  <int>       <dbl>\n1  2000      222483\n2  2001      231453\n3  2002      234600\n4  2003      253909\n5  2004      283999\n```\n:::\n\n```{.r .cell-code}\nyrmon <- c(\"year\", \"month\")\ngroup_str(txhousing, yrmon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 3\n   year month total_sales\n  <int> <int>       <dbl>\n1  2000     1       11411\n2  2000     2       15674\n3  2000     3       20202\n4  2000     4       18658\n5  2000     5       22388\n```\n:::\n:::\n\n\nIf you want the summarise column to have a custom name like `total_<sumvar>`, then you can wrap the value in quotes as below. This method uses the `glue` syntax enabled by the `:=` walrus operator. The walrus operator takes either a raw name or a character string on its LHS.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_raw2 <- function(df, grp, sumvar) {\n  df %>% \n    group_by({{grp}}) %>% \n    summarise(\"total_{{sumvar}}\" := sum({{sumvar}}, na.rm = TRUE),\n              .groups = 'drop')  %>% \n    head(n=5)\n}\n\ngroup_raw2(txhousing, year, sales)            # Sum of sales per year\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n   year total_sales\n  <int>       <dbl>\n1  2000      222483\n2  2001      231453\n3  2002      234600\n4  2003      253909\n5  2004      283999\n```\n:::\n\n```{.r .cell-code}\ngroup_raw2(txhousing, month, listings)        # Sum of listings per month\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 x 2\n  month total_listings\n  <int>          <dbl>\n1     1        1854661\n2     2        1888104\n3     3        1949187\n4     4        1991278\n5     5        2038932\n```\n:::\n:::\n\n\nAfter writing so many examples, I see a pattern. `group_by()` works with techniques similar to `select()` while `summarise()` works with techniques similar to `mutate()`.\n\n# (Slightly Better) Examples\n\nThe `txhousing` is a city-wise monthly sales and volume dataset. It has a `year` and `month` column. Let us create a `date` column and keep only those columns relevant for our custom `tx_summary()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_df <- txhousing %>% \n  mutate(date = lubridate::as_date(glue::glue(\"{year}-{month}-01\"))) %>% \n  select(city, date, sales, volume)\n```\n:::\n\n\n### `mutate()` example\n\nNow let us create the `create_ymq()` function. This function would take 2 arguments, a data frame `df` and a raw name of a date column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_ymq <- function(df, date_col) {\n  stopifnot(inherits(df, \"data.frame\"))\n  stopifnot(class(df %>% dplyr::pull({{date_col}})) == 'Date')\n  dplyr::mutate(df,\n                Year = lubridate::year({{date_col}}),\n                nHalf = lubridate::semester({{date_col}}),\n                yHalf = lubridate::semester({{date_col}}, with_year = TRUE),\n                dHalf = paste0(lubridate::semester({{date_col}}), \"H\", format({{date_col}},\"%y\")),\n                nQtr = lubridate::quarter({{date_col}}),\n                yQtr = lubridate::quarter({{date_col}}, with_year = TRUE),\n                dQtr = paste0(lubridate::quarter({{date_col}}),\"Q\", format({{date_col}},\"%y\")),\n                Month = lubridate::month({{date_col}}),\n                yMonth = as.numeric(format({{date_col}}, \"%Y.%m\")),\n                dMonth = format({{date_col}}, \"%b %Y\")\n                )\n}\n\ncreate_ymq(df = small_df, date_col = date) %>% glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 8,602\nColumns: 14\n$ city   <chr> \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene\", \"Abilene~\n$ date   <date> 2000-01-01, 2000-02-01, 2000-03-01, 2000-04-01, 2000-05-01, 20~\n$ sales  <dbl> 72, 98, 130, 98, 141, 156, 152, 131, 104, 101, 100, 92, 75, 112~\n$ volume <dbl> 5380000, 6505000, 9285000, 9730000, 10590000, 13910000, 1263500~\n$ Year   <dbl> 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 200~\n$ nHalf  <int> 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2, ~\n$ yHalf  <dbl> 2000.1, 2000.1, 2000.1, 2000.1, 2000.1, 2000.1, 2000.2, 2000.2,~\n$ dHalf  <chr> \"1H00\", \"1H00\", \"1H00\", \"1H00\", \"1H00\", \"1H00\", \"2H00\", \"2H00\",~\n$ nQtr   <int> 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 1, 1, 1, 2, 2, 2, 3, 3, 3, ~\n$ yQtr   <dbl> 2000.1, 2000.1, 2000.1, 2000.2, 2000.2, 2000.2, 2000.3, 2000.3,~\n$ dQtr   <chr> \"1Q00\", \"1Q00\", \"1Q00\", \"2Q00\", \"2Q00\", \"2Q00\", \"3Q00\", \"3Q00\",~\n$ Month  <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, ~\n$ yMonth <dbl> 2000.01, 2000.02, 2000.03, 2000.04, 2000.05, 2000.06, 2000.07, ~\n$ dMonth <chr> \"Jan 2000\", \"Feb 2000\", \"Mar 2000\", \"Apr 2000\", \"May 2000\", \"Ju~\n```\n:::\n:::\n\n\n### `group_by()` example\n\nNow that we have a function that creates various date-related columns, let us create a function that let's you create summary tables like annual sales per city, quarterly volumes per city etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntx_summary <- function(df, grp_col, sum_col) {\n  df %>% \n    group_by(city, {{grp_col}}) %>% \n    summarise(\"total_{{sum_col}}\" := sum({{sum_col}}, na.rm = TRUE), .groups = 'drop')\n}\n```\n:::\n\n\nUsing these 2 functions, we can now create multiple summary tables\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall_df_with_date_cols <- small_df %>% create_ymq(date_col = date)\n\n# Annual Sales per city\nsmall_df_with_date_cols %>% tx_summary(grp_col = Year, sum_col = sales)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 736 x 3\n   city     Year total_sales\n   <chr>   <dbl>       <dbl>\n 1 Abilene  2000        1375\n 2 Abilene  2001        1431\n 3 Abilene  2002        1516\n 4 Abilene  2003        1632\n 5 Abilene  2004        1830\n 6 Abilene  2005        1977\n 7 Abilene  2006        1997\n 8 Abilene  2007        2003\n 9 Abilene  2008        1651\n10 Abilene  2009        1634\n# ... with 726 more rows\n```\n:::\n\n```{.r .cell-code}\n# Half Yearly volumes per city\nsmall_df_with_date_cols %>% tx_summary(grp_col = yHalf, sum_col = volume)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,472 x 3\n   city    yHalf total_volume\n   <chr>   <dbl>        <dbl>\n 1 Abilene 2000.     55400000\n 2 Abilene 2000.     53175000\n 3 Abilene 2001.     55795000\n 4 Abilene 2001.     58570000\n 5 Abilene 2002.     55305000\n 6 Abilene 2002.     63370000\n 7 Abilene 2003.     58175000\n 8 Abilene 2003.     77500000\n 9 Abilene 2004.     74205000\n10 Abilene 2004.     85465000\n# ... with 1,462 more rows\n```\n:::\n\n```{.r .cell-code}\n# Quarterly Sales per city\nsmall_df_with_date_cols %>% tx_summary(grp_col = yQtr, sum_col = sales)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,898 x 3\n   city     yQtr total_sales\n   <chr>   <dbl>       <dbl>\n 1 Abilene 2000.         300\n 2 Abilene 2000.         395\n 3 Abilene 2000.         387\n 4 Abilene 2000.         293\n 5 Abilene 2001.         305\n 6 Abilene 2001.         394\n 7 Abilene 2001.         401\n 8 Abilene 2001.         331\n 9 Abilene 2002.         295\n10 Abilene 2002.         425\n# ... with 2,888 more rows\n```\n:::\n\n```{.r .cell-code}\n# Monthly Volumes per city\nsmall_df_with_date_cols %>% tx_summary(grp_col = yMonth, sum_col = volume)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8,602 x 3\n   city    yMonth total_volume\n   <chr>    <dbl>        <dbl>\n 1 Abilene  2000.      5380000\n 2 Abilene  2000.      6505000\n 3 Abilene  2000.      9285000\n 4 Abilene  2000.      9730000\n 5 Abilene  2000.     10590000\n 6 Abilene  2000.     13910000\n 7 Abilene  2000.     12635000\n 8 Abilene  2000.     10710000\n 9 Abilene  2000.      7615000\n10 Abilene  2000.      7040000\n# ... with 8,592 more rows\n```\n:::\n:::\n\n\n### More ideas\n\nYou could further extend this by creating a custom filtering function that gives you, say, the rows with the highest or lowest `total_sales` or `total_volume`.\n\n# Conclusion\n\nThe ability to create such dynamic functions, enabled by the wonderful {dplyr} package, allows us to level-up in terms of programming with R and helps make our code neat and tidy.\n\n![How I feel while creating custom functions with {dplyr}! I can almost hear the music! Source: imgur.com](https://i.imgur.com/H9jo8OB.gif)\n\n# References\n\n-   Hadley Wickham, Romain François, Lionel Henry and Kirill Müller (2022). dplyr: A Grammar of Data Manipulation. R package version 1.0.9. https://CRAN.R-project.org/package=dplyr\n-   https://dplyr.tidyverse.org/articles/programming.html\n-   H. Wickham. ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York, 2016. https://ggplot2.tidyverse.org\n-   Jim Hester and Jennifer Bryan (2022). glue: Interpreted String Literals. R package version 1.6.2. https://CRAN.R-project.org/package=glue\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}